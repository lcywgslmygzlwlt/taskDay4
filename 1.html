<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script type="text/javascript">
    // const _completeDeepClone = (target, map = new Map()) => {
    //     // 补全代码

    // }

    const obj = {
        name: 'lin'
    }

    const newObj = Object.assign({}, obj)

    obj.name = 'xxx' // 改变原来的对象

    console.log(newObj) // { name: 'lin' } 新对象不变

    console.log(obj == newObj) // false 两者指向不同地址

    function deepClone(target, hash = new WeakMap()) { // 额外开辟一个存储空间WeakMap来存储当前对象
        if (target === null) return target // 如果是 null 就不进行拷贝操作
        if (target instanceof Date) return new Date(target) // 处理日期
        if (target instanceof RegExp) return new RegExp(target) // 处理正则
        if (target instanceof HTMLElement) return target // 处理 DOM元素

        if (typeof target !== 'object') return target // 处理原始类型和函数 不需要深拷贝，直接返回

        // 是引用类型的话就要进行深拷贝
        if (hash.get(target)) return hash.get(target) // 当需要拷贝当前对象时，先去存储空间中找，如果有的话直接返回
        const cloneTarget = new target.constructor() // 创建一个新的克隆对象或克隆数组
        hash.set(target, cloneTarget) // 如果存储空间中没有就存进 hash 里

        Reflect.ownKeys(target).forEach(key => { // 引入 Reflect.ownKeys，处理 Symbol 作为键名的情况
            cloneTarget[key] = deepClone(target[key], hash) // 递归拷贝每一层
        })
        return cloneTarget // 返回克隆的对象
    }
    const obj1 = {
        a: true,
        b: 100,
        c: 'str',
        d: undefined,
        e: null,
        f: Symbol('f'),
        g: {
            g1: {} // 深层对象
        },
        h: [], // 数组
        i: new Date(), // Date
        j: /abc/, // 正则
        k: function () { }, // 函数
        l: [document.getElementById('foo')] // 引入 WeakMap 的意义，处理可能被清除的 DOM 元素
    }

    obj1.obj = obj1 // 循环引用

    const name = Symbol('name')
    obj[name] = 'lin'  // Symbol 作为键

    const newObj1 = deepClone(obj1)

    console.log(newObj1)



</script>

</html>